"""
Example inferring multiple biexponential decay models arranged into a
4D voxelwise image.
"""
import argparse
import sys
import os

import numpy as np
import nibabel as nib
import tensorflow as tf

import vaby 

cli = argparse.ArgumentParser()
cli.add_argument("--method", help="Inference method", choices=["avb", "svb"], default="avb")
cli.add_argument("--amp1", help="Ground truth amplitude 1", type=float, default=42.0)
cli.add_argument("--rate1", help="Ground truth decay rate 1", type=float, default=1.0)
cli.add_argument("--amp2", help="Ground truth amplitude 2", type=float, default=42.0)
cli.add_argument("--rate2", help="Ground truth decay rate 2", type=float, default=0.1)
cli.add_argument("--dt", help="Time resolution", type=float, default=0.1)
cli.add_argument("--nt", help="Number of time points", type=int, default=100)
cli.add_argument("--size", help="Approximate number of data examples", type=int, default=100)
cli.add_argument("--noise", help="Ground truth noise amplitude (std dev)", type=float, default=5)
cli.add_argument("--rseed", help="Random number seed to give reproducible results", type=int)
cli.add_argument("--debug", help="Debug logging", action="store_true", default=False)
cli.add_argument("--fabber", help="Run Fabber as a comparison", action="store_true", default=False)
opts = cli.parse_args()

if opts.rseed:
    np.random.seed(opts.rseed)
    tf.random.set_seed(opts.rseed)

options = {
    "method" : opts.method,
    "dt" : opts.dt,
    "save_mean" : True,
    "save_model_fit" : True,
    "debug" : opts.debug,
    "save_log" : True,
    "output" : f"biexps_example_{opts.method}_out",
    "log_stream" : sys.stdout,
}

if opts.method == "svb":
    options.update({
        "epochs" : 300,
        "learning_rate" : 0.1,
        "sample_size" : 5,
        "batch_size" : 10,
    })
elif opts.method == "avb":
    options.update({
        "max_iterations" : 200,
    })

if not os.path.exists(options["output"]):
    os.makedirs(options["output"])

# Ground truth parameters
PARAMS_TRUTH = [opts.amp1, opts.rate1, opts.amp2, opts.rate2]
NOISE_STD_TRUTH = opts.noise
NOISE_VAR_TRUTH = NOISE_STD_TRUTH**2
NOISE_PREC_TRUTH = 1/NOISE_VAR_TRUTH
print("Ground truth: a=%s, r=%s, noise=%f (std.dev.)" % (PARAMS_TRUTH[::2], PARAMS_TRUTH[1::2], NOISE_STD_TRUTH))

# Observed data samples are generated by Numpy from the ground truth
# Gaussian distribution. Reducing the number of samples should make
# the inference less 'confident' - i.e. the output variances for
# MU and BETA will increase
NX = int(opts.size**(1.0/3))
NY, NZ = NX, NX
print(f"Dimensions of volume: {NX}x{NY}x{NZ} - actual number of samples: {NX*NY*NX}")

t = np.array([float(t)*opts.dt for t in range(opts.nt)])
params_voxelwise = np.tile(np.array(PARAMS_TRUTH)[..., np.newaxis, np.newaxis], (1, NX*NY*NZ, 1))
temp_model = vaby.get_model_class("biexp")(None, dt=opts.dt)
DATA_CLEAN = temp_model.evaluate(params_voxelwise, t).numpy()
DATA_NOISY = DATA_CLEAN + np.random.normal(0, NOISE_STD_TRUTH, DATA_CLEAN.shape)

# Save clean and noisy data
niidata = DATA_CLEAN.reshape((NX, NY, NZ, opts.nt))
nii = nib.Nifti1Image(niidata, np.identity(4))
nii.to_filename(os.path.join(options["output"], "data_biexp_clean.nii.gz"))
niidata = DATA_NOISY.reshape((NX, NY, NZ, opts.nt))
nii = nib.Nifti1Image(niidata, np.identity(4))
nii.to_filename(os.path.join(options["output"], "data_biexp_noisy.nii.gz"))

input_data = os.path.join(options["output"], "data_biexp_noisy.nii.gz")

if opts.fabber:
    import os
    os.system(f"fabber_exp --data={input_data}  --max-iterations=20 --output=biexps_example_fabber_out --dt=%.3f --model=exp --num-exps=2 --method=vb --noise=white --save-model-fit --overwrite" % opts.dt)

runtime, inf = vaby.run(input_data, "biexp", **options)
