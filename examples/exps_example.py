"""
Example inferring multiple exponential decay models arranged into a
4D voxelwise image.

This example uses the main() interface as used by the command line
application to simplify running the inference and saving the output
"""
import argparse
import sys

import numpy as np
import nibabel as nib

import vaby 

cli = argparse.ArgumentParser()
cli.add_argument("--method", help="Inference method", choices=["avb", "svb"], default="avb")
cli.add_argument("--amp", help="Ground truth amplitude", type=float, default=42.0)
cli.add_argument("--rate", help="Ground truth decay rate", type=float, default=0.5)
cli.add_argument("--dt", help="Time resolution", type=float, default=0.1)
cli.add_argument("--nt", help="Number of time points", type=int, default=100)
cli.add_argument("--size", help="Approximate number of data examples", type=int, default=100)
cli.add_argument("--noise", help="Ground truth noise amplitude (std dev)", type=float, default=5)
cli.add_argument("--rseed", help="Random number seed to give reproducible results", type=int)
cli.add_argument("--debug", help="Debug logging", action="store_true", default=False)
cli.add_argument("--fabber", help="Run Fabber as a comparison", action="store_true", default=False)
#cli.add_argument("--plot", help="Show output graphically", action="store_true", default=False)
opts = cli.parse_args()

if opts.rseed:
    np.random.seed(opts.rseed)

# Ground truth parameters
PARAMS_TRUTH = [opts.amp, opts.rate]
NOISE_STD_TRUTH = opts.noise
NOISE_VAR_TRUTH = NOISE_STD_TRUTH**2
NOISE_PREC_TRUTH = 1/NOISE_VAR_TRUTH
print("Ground truth: a=%f, r=%f, noise=%f (std.dev.)" % (PARAMS_TRUTH[0], PARAMS_TRUTH[1], NOISE_STD_TRUTH))

# Observed data samples are generated by Numpy from the ground truth
# Gaussian distribution. Reducing the number of samples should make
# the inference less 'confident' - i.e. the output variances for
# MU and BETA will increase
NX = int(opts.size**(1.0/3))
NY, NZ = NX, NX
print(f"Dimensions of volume: {NX}x{NY}x{NZ} - actual number of samples: {NX*NY*NX}")

t = np.array([float(t)*opts.dt for t in range(opts.nt)])
params_voxelwise = np.tile(np.array(PARAMS_TRUTH)[..., np.newaxis, np.newaxis], (1, NX*NY*NZ, 1))
temp_model = vaby.get_model_class("exp")(None, dt=opts.dt)
DATA_CLEAN = temp_model.evaluate(params_voxelwise, t).numpy()
DATA_NOISY = DATA_CLEAN + np.random.normal(0, NOISE_STD_TRUTH, DATA_CLEAN.shape)
niidata = DATA_NOISY.reshape((NX, NY, NZ, opts.nt))
nii = nib.Nifti1Image(niidata, np.identity(4))
nii.to_filename("data_exp_noisy.nii.gz")

if opts.fabber:
    import os
    os.system("fabber_exp --data=data_exp_noisy  --max-iterations=20 --output=exps_example_fabber_out --dt=%.3f --model=exp --num-exps=1 --method=vb --noise=white --overwrite" % opts.dt)

options = {
    "method" : opts.method,
    "dt" : opts.dt,
    "save_mean" : True,
    #"save_free_energy" : True,
    #"save_model_fit" : True,
    "debug" : opts.debug,
    "save_log" : True,
    "log_stream" : sys.stdout,
}

if opts.method == "svb":
    options.update({
        "epochs" : 500,
        "learning_rate" : 0.1,
        "sample_size" : 5, 
    })
elif opts.method == "avb":
    options.update({
        "max_iterations" : 20,
    })

runtime, inf = vaby.run("data_exp_noisy.nii.gz", "exp", "exps_example_out", **options)
