"""
Example inferring multiple exponential decay models arranged into a
4D voxelwise image using a surface model
"""
import argparse
import sys

import numpy as np
import nibabel as nib

import vaby 

cli = argparse.ArgumentParser()
cli.add_argument("--method", help="Inference method", choices=["avb", "svb"], default="avb")
cli.add_argument("--amp", help="Ground truth amplitude", type=float, default=42.0)
cli.add_argument("--rate", help="Ground truth decay rate", type=float, default=0.5)
cli.add_argument("--dt", help="Time resolution", type=float, default=0.1)
cli.add_argument("--nt", help="Number of time points", type=int, default=100)
cli.add_argument("--refimg", help="Nifti file containing reference space")
cli.add_argument("--mask", help="Nifti file containing binary mask")
cli.add_argument("--noise", help="Ground truth noise amplitude (std dev)", type=float, default=5)
cli.add_argument("--rseed", help="Random number seed to give reproducible results", type=int)
cli.add_argument("--debug", help="Debug logging", action="store_true", default=False)
#cli.add_argument("--plot", help="Show output graphically", action="store_true", default=False)
opts = cli.parse_args()

if opts.rseed:
    np.random.seed(opts.rseed)

# Ground truth parameters
#PARAMS_TRUTH = [opts.amp, opts.rate]
#NOISE_STD_TRUTH = opts.noise
#NOISE_VAR_TRUTH = NOISE_STD_TRUTH**2
#NOISE_PREC_TRUTH = 1/NOISE_VAR_TRUTH
#print("Ground truth: a=%f, r=%f, noise=%f (std.dev.)" % (PARAMS_TRUTH[0], PARAMS_TRUTH[1], NOISE_STD_TRUTH))

# Observed data samples are generated by Numpy from the ground truth
# Gaussian distribution. Reducing the number of samples should make
# the inference less 'confident' - i.e. the output variances for
# MU and BETA will increase
#ref_nii = nib.load(opts.refimg)
#shape = ref_nii.shape[:3]
#print(f"Dimensions of volume: {shape}")

#t = np.array([float(t)*opts.dt for t in range(opts.nt)])
#params_voxelwise = np.tile(np.array(PARAMS_TRUTH)[..., np.newaxis, np.newaxis], (1, np.prod(shape), 1))
#temp_model = vaby.get_model_class("exp")(None, dt=opts.dt)
#DATA_CLEAN = temp_model.evaluate(params_voxelwise, t).numpy()
#DATA_NOISY = DATA_CLEAN + np.random.normal(0, NOISE_STD_TRUTH, DATA_CLEAN.shape)
#niidata = DATA_NOISY.reshape(list(shape) + [opts.nt,])
#nii = nib.Nifti1Image(niidata, None, ref_nii.header)
#nii.update_header()
#nii.to_filename("data_exp_noisy.nii.gz")

plds = [0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
repeats = 8
options = {
    "method" : opts.method,
    "mask" : "tk/mask.nii.gz",
    "plds": plds, 
    "repeats": repeats, 
    "casl": True,
#    "dt" : opts.dt,
    "save_mean" : True,
    "save_model_fit" : True,
    "save_input_data" : True,
    "save_native" : True,
    "save_model" : True,
    "model_structures" : [
        {
            "name" : "L",
            "type" : "CorticalSurface",
            "white" : "tk/103818.L.mid.32k_fs_LR.surf.gii",
            "pial" : "tk/103818.L.very_inflated.32k_fs_LR.surf.gii",
            #"save-projector" : "gii/HCA6002236_V1_MR.L_proj.h5",
            "projector" : "tk/103818_L_hemi.h5",
        },
        #{
        #    "name" : "R",
        #    "type" : "CorticalSurface",
        #    "white" : "gii/HCA6002236_V1_MR.R.white.native.surf.gii",
        #    "pial" : "gii/HCA6002236_V1_MR.R.pial.native.surf.gii",
        #    "save-projector" : "gii/HCA6002236_V1_MR.R_proj.h5",
        #    #"projector" : "gii/HCA6002236_V1_MR.R_proj.h5",
        #},
        {
            "name" : "WM",
            "type" : "PartialVolumes",
            "vol_data" : "tk/wm_pv.nii.gz",
            "mask" : "tk/mask.nii.gz"
        },
    ],
    "debug" : opts.debug,
    "save_log" : True,
    "log_stream" : sys.stdout,
}

if opts.method == "svb":
    options.update({
        "epochs" : 500,
        "learning_rate" : 0.2,
        "sample_size" : 5, 
    })
elif opts.method == "avb":
    options.update({
        "max_iterations" : 50,
    })

runtime, inf = vaby.run("tk/hybrid_simdata.nii.gz", "aslrest", "hybrid_asl_example_out", **options)
